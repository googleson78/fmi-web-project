<!doctype html>
<html>
  <head>
    <title> Servant - уеб интърфейси чрез типове </title>
    <meta charset="utf-8">
    <link href="./css/styles.css" rel="stylesheet"/>
  </head>
  <body>
    <div class="body-content">
      <div class="navigation">
        <nav id="navig" class="contents menu">
          <h1 class="contents-title"> Съдържание </h1>
          <ul class="menu">
            <li class="menu"> <a class="active" href="#intro"> Въведение </a></li>
            <li class="menu"> <a href="#example">Пример</a></li>
            <li class="menu"> <a href="#combinators">Основни комбинатори</a> </li>
            <li class="menu"> <a href="#serving">Имплементиране на сървър</a> </li>
            <li class="menu"> <a href="#querying">Правене на заявки към сървър</a> </li>
            <li class="menu"> <a href="#resources">Използвани ресурси</a> </li>
          </ul>
        </nav>
      </div>

      <section class="title content">
          <h1> Servant - уеб интърфейси чрез типове </h1>
      </section>

      <div class="content">
        <div class="section" id="intro">
          <h2>Въведение</h2>
          <p>
          Всеки уеб сървър има "приложно-програмен интерфейс" (наричан оттук-нататък "API"), който се случва комуникацията му с външния свят,
          независимо от това дали имплицитно в програмния код, или също толкова неформално - като някакъв вид документация.
          <br>
          Това е незадоволяващо, защото правилната му употреба разчита изцяло на
          <ul>
            <li>човека имплементиращ сървъра</li>
            <li>човека имплементиращ заявки към въпросното API</li>
          </ul>
          Има множество неща които са описани в API-то, за които трябва да се мисли:
          <ul>
            <li>на какъв адрес се праща заявката</li>
            <li>как се кодират данните които се пращат/получават</li>
            <li>дали трябва да очакваме/пращаме някакви header-и, тела на заявката или параметри на заявката</li>
          </ul>
          Но защо? Нали е <b>описано</b> в API-то вече един път. Защо трябва да се грижим да превеждаме това описание на код? Не може ли по описанието да получим тези почти механични части "безплатно"?
          <br><br>
          Servant<a href="#servant-frontpage">[1]</a> е библиотека и същевременно вграден предметно-ориентиран език (наричан оттук-нататък "DSL"/"EDSL") за Haskell, позволяващ
          спецификацията на API-та <b>в</b> типовете система на Haskell.
          <br><br>
          Това че нашият интърфейс става (почти първокласен) гражданин на езика за програмиране ни позволява да използваме всичките подходи за генерично програмиране, за да автоматизираме
          гореспоменатите болки, както и да получим други неща "безплатно", като генериране на документация или функции за заявки на други езици.
          </p>
        </div>

        <div class="section" id="example">
          <h2>Пример</h2>
          Нека да разгледаме прост пример, адаптиран от статия за Servant<a href="#servant-paper">[2]</a>, но модернизиран за днешното състояние на библиотеката.
          <br>
          Той ще служи за обяснения и демонстрация на останалите функционалности:
          <pre><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GeneralisedNewtypeDeriving #-}
{-# LANGUAGE TypeOperators #-}

import Data.Aeson
import Servant.API

newtype CounterVal = CounterVal {getCounterVal :: Int}
  deriving (Show, Num, FromJSON, ToJSON)

type Counter = GetCounter :<|> StepCounter
type GetCounter = Get '[JSON] CounterVal
type StepCounter = "step" :> PostNoContent
          </code></pre>
          За да се изпробват примерите из документа ще са нужни няколко библиотеки - aeson, servant, servant-server, servant-client, servant-docs.
          <br><br>
          Първите няколко реда - <code>LANGUAGE</code> директивите пускат нужните разширения на езика, за по-сложни манипулации на типове.
          <br>
          <code>import</code> декларациите служат за вкарване на нужните ни библиотечни функции и типове.
          <br><br>
          В примера ще дефинираме API към число брояч с две крайни точки:
          <ul>
            <li> <code>/</code> - коренът на API-то ни ще служи за взимане на сегашната стойност на брояча</li>
            <li> <code>/step</code> - ще служи за инкрементиране на брояча</li>
          </ul>
          Като добра Haskell практика правим нов тип който да обвива брояча ни, различавайки го като тип от "чист" <code>Int</code>,
          <br>
          По-късно ще се възползваме от това, за да закачим допълнителна информация към него, при генерирането на документация.
          <br>
          Благодарение на богатия <code>deriving</code> механизъм на Haskell за преизползване на имплементации на типови класове (нещо наподобяващо интърфейси в ООП света),
          можем автоматично да получим (в този ред) обръщане към низ, операции за числа, десереализация от JSON и сереализация към JSON
          <br>
          Имплементациите на тези операции съответстват едно към едно с тези на типа който обвиваме (в този случай <code>Int</code>), което позволява и това автомагическо преизползване.
          <br><br>
          Нека разгледаме по-подробно останалата част от програмата ни:
          <h4><code>type Counter = GetCounter :<|> StepCounter</code></h4>
          Тук декларираме типов синоним - както се разбрахме, нашето API ще е изразено като <b>тип</b> в Haskell.
          <br>
          Типът <code>Counter</code> представлява цялото ни API - то е комбинация, чрез оператора <code>:<|></code>,
          на два други типа - <code>GetCounter</code> и <code>StepCounter</code>.
          <br>
          В Haskell операторът <code>a <|> b</code> (или някаква негова вариация) често се използва за да се означи "а или b", по подоба на граматики.
          <br>
          В този случай <code>:<|></code> е <b>типов оператор</b>, взимащ като аргументи две други API-та, означавайки комбинацията им:
          <br>
          Ако искаме да направим заявка към <code>GetCounter :<|> StepCounter</code>, трябва да направим заявка към <code>GetCounter</code> <b>или</b> към <code>StepCounter</code>.
          <h4><code>type GetCounter = Get '[JSON] CounterVal</code></h4>
          Типовият синоним <code>GetCounter</code> ще е крайната точка на която можем да вземем сегашното състояние на брояча.
          <br>
          За да декларираме една крайна точка трябва да кажем няколко неща:
          <ul>
            <li><b>на какъв HTTP метод ще отговаря</b></li>
            Тази роля изпълнява <code>Get</code> - още една типова функция, с два аргумента, разяснени по-долу.
            <li><b>на какви формати ще отговаря</b></li>
            В HTTP света това е на какъв <code>Accept</code> header ще отговаряме и съотвенто какъв <code>Content-Type</code> ще връщаме.
            <br>
            В нашия случай това е JSON - подадено като първи аргумент на <code>Get</code> в <b>списък на ниво типове</b> с един елемент -
            <b>типът <code>JSON</code></b>.
            <br>
            Ако искахме да можем да отговаряме освен това и с <code>text/plain</code> бихме направили този списък <code>'[JSON, PlainText]</code>.
            <li><b>с какви данни ще отговаря</b></li>
            В нашия случай това са данни от типа <code>CounterVal</code>, подаден като втори аргумент на <code>Get</code>.
            <br>
            Ключов момент тук е, че преди да се опитаме да сервираме/правим заявки, трябва нашият тип да поддържа подадените като втори аргумент формати.
            Иначе програмата няма да се компилира, както и искаме, защото няма как да Servant да измисли от нищото как да направи конверсиите от нашия произволен тип
            към/от исканите формати.
            <br>
            Тук тази роля изпълняват инстанциите на <code>FromJSON</code> и <code>ToJSON</code> за <code>CounterVal</code>.
          </ul>
          <h4><code>type StepCounter = "step" :> PostNoContent</code></h4>
          Типовият синоним <code>StepCounter</code> ще е крайната точка на която можем да инкрементираме брояча ни.
          <br>
          Тук виждаме нов типове оператор - <code>:></code>. Той взима два аргумента - <b>низ на ниво типове</b> и друго API.
          <br>
          Ако с <code>:<|></code> изразяваме "разклонение", то с <code>:></code> изразяваме "задълбаване":
          <br>
          Ако искаме да направим заявка към <code>"step" :> B</code> то трябва да направим заявка към <code>B</code>, като на пътя в заявката трябва да сложим префикс <code>step/</code>.
          <br>
          Трябва да се отбележи че с него можем да вкарваме и допълнителни "аргументи" към заявка - например параметри на заявката, header-и, обхващани стойности от пътя.
          Те ще бъдат разгледани по-подробно в <a href="#combinators">Основни комбинатори</a>.
          <br>
          Вторият аргумент на <code>:></code> - типът <code>PostNoContent</code>, е удобен вграден синоним, който индикира че:
          <ul>
            <li>ще отговаряме на <code>POST</code> заявки</li>
            <li>няма да връщаме никакво съдържание - съответно нямаме и никакви формати за (де)кодиране</li>
            <li>от страната на сървъра ще връщаме <code>204 No Content</code></li>
          </ul>
          <br>
          Важно е да се отбележи че всичката тази информация не "прави" нищо сама по себе си - тя е важна по-късно когато искаме да използваме по някакъв начин API-то,
          било то имплементиране сървър за него, правене на заявки към него или генериране на документация за него.
        </div>

        <div class="section" id="combinators">
          <h2>Основни комбинатори</h2>
          В Servant има набор от основни "комбинатори"</code><a href="#combinator">[3]</a>, които позволяват сглабянето на по-малки API-та за да се получи нещо по-голямо.
          <br>
          Тук ще разгледаме най-често използваните такива, както и как се правят заявки към тях.
          <br>
          Наблягаме пак на факта, че всички тези типове в крайна сметка са <b>само синтаксис</b> - те не "правят нищо" по себе си, а са само интуитивна индикация за какво искаме да <b>означават</b>.
          <br>
          Това каква реално е тяхната семантика е отговорност на лицето което ги ползва и в тази секция ще бъдат описани в контекст на най-честите им употреби - servant-server и servant-client.
          <br>
          За добиване на по-конкретна представа за употребата на повечето от тези комбинатори секциите <a href="#serving">имплементиране на сървър</a> и <a href="#querying">правене на заявки към сървър</a> са полезни.
          <h4><code>(:<|>)</code></h4>
          Позволява ни да правим <b>"обединение"</b> на две API-та, т.е. ако имаме предварително две такива, с този оператор правим ново, което сервира и двете, както е демонстирано в примера
          <br>
          Съществува и типът <code>EmptyAPI</code><a href="#empty-api">[4]</a>, чрез който създателите на библиотеката се стремят да направят <code>(:<|>)</code> на <b>моноидална</b><a href="#monoid">[5]</a> операция, т.е.
          <code>EmptyAPI</code> е <b>неутрален елемент</b> на <code>(:<|>)</code>.
          Той е API което не отговаря на никакви заявки и съответно не могат да му бъдат правени заявки.
          <br>
          За да достъпим <code>api1 :<|> api2</code> трябва да можем да достъпим <code>api1</code> <b>или</b> <code>api2</code>
          <br>
          При припокриване (например <code>StepCounter :<|> StepCounter</code>, използвайки горния пример) на двете API-та се избира винаги лявото.
          <h4><code>(:>)</code></h4>
          Позволява ни да правим <b>"влагане"</b> на API-та, както е показано в примера.
          <br>
          За да достъпим <code>api1 :> api2 </code> трябва да "изпълним изискванията" за достъпване на <code>api1</code> <b>и</b> тези на <code>api2</code>.
          <h4>Низове на типово ниво</h4>
          Всеки низ на типово ниво е сам по себе си "константен комбинатор", със семантиката на "под-адрес", както е демонстрирано в примера.
          <h4><code>Get</code>/<code>Post</code>/<code>Put</code>/etc</h4>
          Комбинатори които отговарят на съответните HTTP методи за заявки.
          <br>
          Всеки от тях взима два аргумента:
          <ul>
            <li>на какви типове (доста близко отговарящи на <code>Content-Type</code>) ще отговаряме</li>
            <li>какъв тип данни (в Haskell-ския смисъл на тип) ще връща сървърът</li>
          </ul>
          Въпреки че Haskell-ските типове данни не съществуват извън Haskell, а само тяхната кодировка (в съответния <code>Content-Type</code>),
          е полезно да говорим за тях:
          <ul>
            <li>по този начин Servant научава как да (де)кодира данни</li>
            <li>ако програмираме изцяло на Haskell (или можем някак да генерирам (де)кодирания на друг езиц), можем да получим автоматично (де)кодирането</li>
            <li>данните които обработваме са директно в нашия "бизнес домейн" - не е нужно да говорим за JSON, когато реално искаме да говорим за <code>User</code></li>
          </ul>
          За да се направи заявка към (например) <code>Get '[JSON, PlainText] User</code> трябва:
          <ul>
            <li>да сложим <code>GET</code> за метод на нашата заявка.</li>
            <li>да сложим подходящия <code>Content-Type</code> - в този случай или json или utf8 кодиран текст.</li>
          </ul>
          При ползване на servant-client естествено тези стъпки са автоматично извършени, както и получаваме автоматично декодирани към правилния Haskell-ски тип данни.
          <br>
          Дуално на това, servant-server се грижи да отговаряме само на подходящи настроени заявки, както и да кодира автоматично данните които пращаме, от Haskell-ските им еквиваленти.
          <br>
          За да работи цялата тази "автомагия" тук, както и в останалите места където има някакво кодиране, се разчита на конкретни широко използвани типови класове, съответстващи на
          дадените <code>Content-Type</code>-ове в този случай.
          <br>
          Обикновено всяко API завършва на един от тези методи, като последно нещо във верига от много пъти приложени <code>(:>)</code>.
          <br>
          Всичките комбинатори от тази група всъщност са дефинирани използвайки един такъв на по-ниско ниво - <code>Verb</code><a href="#servant-verb">[6]</a>.
          <h4><code>ReqBody</code></code></h4>
          Комбинатор, който добавя тяло на заявката към API.
          <br>
          Той има два аргумента и ползата му е подобна на комбинаторите за методи - посочваме кодиране (<code>Content-Type</code>) и съответно Haskell-ски тип, който да очакваме, със същите съображения както преди.
          <br>
          Тъй като това е нещо което клиентът праща и сървърът приема, семантиката му е "дуална" на тази на комбинаторите за методи - при сървъра го получаваме като аргумент, а при клиента трябва да го подадем като аргумент.
          <br>
          Извън servant-client, за да се направи заявка към <code>ReqBody '[JSON] User</code> е достатъчно да се сложи като тяло на заявката JSON-кодирана версия на <code>User</code>.
          <br>
          <code>ReqBody</code>, както и повечето други носещи данни комбинатори, притежава задължителен и незадължителен вариант, като това се отразява в Haskell света чрез ползването на <code>Maybe</code> типа, който позволява "отсъствие" на данни (подобно на <code>std::optional</code> например).
          <h4><code>QueryParam</code></code></h4>
          Комбинатор, който добавя параметри или флаг на заявката към API.
          <br>
          Той има два аргумента - име, към което да закачаме аргумента, и Haskell-ски тип, който да (де)кодираме.
          Има допълнително и <code>QueryFlag</code> с един аргумент име, което е <code>QueryParam</code> специализирано до булева стойност.
          <br>
          При ползването на servant-client е нужно само да подадем съответния Haskell-ски тип като аргумент на Haskell-ска функция, както и дуално получаваме Haskell-ски тип като аргумент на функция, при servant-server.
          Тук за (де)кодиране се използват <code>ToHttpApiData</code>/<code>FromHttpApiData</code><a href="#api-data">[7]</a>
          <br>
          Извън servant-client, за да се направи заявка към <code>QueryParam "asdf" Int :> api1 </code> е достатъчно да направим заявка към <code>api1</code>, като към края на адреса ѝ закачим (при всичките други параметри) <code>asdf1=1</code>.
          <h4><code>Header</code></code></h4>
          Комбинатор, добавящ заглавна част(header) на заявката към API.
          <br>
          Той има два аргумента и се ползва по подобен на <code>QueryParam</code> начин - дава се име и Haskell-ски тип данни, който да очакваме/предаваме.
          <br>
          Семантиката му в servant-server и servant-client е почти неразличима от тази на <code>QueryParam</code> - дори същите типови класове са използвани за (де)кодиране.
          <br>
          Извън тях, заявка към <code>Header "asdf" Int :> api1</code> е същото като заявка към <code>api1</code>, като допълнително е добавен header <code>asdf: 5</code>.
        </div>

        <div class="section" id="serving">
          <h2>Имплементиране на сървър</h2>
          WIP
        </div>

        <div class="section" id="querying">
          <h2>Правене на заявки към сървър</h2>
          WIP
        </div>

        <div class="section" id="resources">
          <h2> Използвани ресурси </h2>
          <ol>
            <li id="servant-frontpage"> <a href="https://www.servant.dev"> "Servant"</a> <br> [https://www.servant.dev], посетено последно на 12.04.2020</li>
            <li id="servant-paper"> <a href="https://alpmestan.com/servant/servant-wgp.pdf"> "Type-level Web APIs with Servant"</a> <br> [https://alpmestan.com/servant/servant-wgp.pdf], посетено последно на 12.04.2020</li>
            <li id="combinator"> <a href="https://wiki.haskell.org/Combinator"> "Combinator"</a> <br> [https://wiki.haskell.org/Combinator], посетено последно на 08.05.2020</li>
            <li id="empty-api"> <a href="https://hackage.haskell.org/package/servant-0.17/docs/Servant-API.html#t:EmptyAPI"> "EmptyAPI"</a> <br> [https://hackage.haskell.org/package/servant-0.17/docs/Servant-API.html#t:EmptyAPI], посетено последно на 08.05.2020</li>
            <li id="monoid"> <a href="https://en.wikipedia.org/wiki/Monoid"> "Monoid"</a> <br> [https://en.wikipedia.org/wiki/Monoid], посетено последно на 08.05.2020</li>
            <li id="servant-verb"> <a href="https://hackage.haskell.org/package/servant-0.17/docs/Servant-API.html#t:Verb"> "Verb"</a> <br> [https://hackage.haskell.org/package/servant-0.17/docs/Servant-API.html#t:Verb], посетено последно на 08.05.2020</li>
            <li id="api-data"> <a href="https://hackage.haskell.org/package/http-api-data-0.4.1.1/docs/Web-HttpApiData.html"> "Web.HttpApiData"</a> <br> [https://hackage.haskell.org/package/http-api-data-0.4.1.1/docs/Web-HttpApiData.html], посетено последно на 08.05.2020</li>
          </ol>
        </div>
      </div>
    </div>

    <script src="vanillajs-scrollspy-master/dist/vanillajs-scrollspy.min.js"></script>
    <script>
      const navbar = document.querySelector('#navig');
      const scrollspy = new VanillaScrollspy(navbar);
      scrollspy.init();
    </script>
  </body>
</html>
