<!doctype html>
<html>
  <head>
    <title> Servant - уеб интърфейси чрез типове </title>
    <meta charset="utf-8">
    <link href="./css/styles.css" rel="stylesheet"/>
  </head>
  <body>
    <div class="body-content">
      <div class="navigation">
        <nav id="navig" class="contents menu">
          <h1 class="contents-title"> Съдържание </h1>
          <ul class="menu">
            <li class="menu"> <a class="active" href="#intro"> Въведение </a></li>
            <li class="menu"> <a href="#example">Пример</a></li>
            <li class="menu"> <a href="#combinators">Основни комбинатори</a> </li>
            <li class="menu"> <a href="#serving">Имплементиране на сървър</a> </li>
            <li class="menu"> <a href="#querying">Правене на заявки към сървър</a> </li>
            <li class="menu"> <a href="#docs">Генериране на документация</a> </li>
            <li class="menu"> <a href="#resources">Използвани ресурси</a> </li>
          </ul>
        </nav>
      </div>

      <section class="title content">
          <h1> Servant - уеб интърфейси чрез типове </h1>
      </section>

      <div class="content">
        <div class="section" id="intro">
          <h2>Въведение</h2>
          <p>
          Всеки уеб сървър има "приложно-програмен интерфейс" (наричан оттук-нататък "API"), който се случва комуникацията му с външния свят,
          независимо от това дали имплицитно в програмния код, или също толкова неформално - като някакъв вид документация.
          <br>
          Това е незадоволяващо, защото правилната му употреба разчита изцяло на
          <ul>
            <li>човека имплементиращ сървъра</li>
            <li>човека имплементиращ заявки към въпросното API</li>
          </ul>
          Има множество неща които са описани в API-то, за които трябва да се мисли:
          <ul>
            <li>на какъв адрес се праща заявката</li>
            <li>как се кодират данните които се пращат/получават</li>
            <li>дали трябва да очакваме/пращаме някакви header-и, тела на заявката или параметри на заявката</li>
          </ul>
          Но защо? Нали е <b>описано</b> в API-то вече един път. Защо трябва да се грижим да превеждаме това описание на код? Не може ли по описанието да получим тези почти механични части "безплатно"?
          <br><br>
          Servant<a href="#servant-frontpage">[0]</a> е библиотека и същевременно вграден предметно-ориентиран език (наричан оттук-нататък "DSL"/"EDSL") за Haskell, позволяващ
          спецификацията на API-та <b>в</b> типовете система на Haskell.
          <br><br>
          Това че нашият интърфейс става (почти първокласен) гражданин на езика за програмиране ни позволява да използваме всичките подходи за генерично програмиране, за да автоматизираме
          гореспоменатите болки, както и да получим други неща "безплатно", като генериране на документация или функции за заявки на други езици.
          </p>
        </div>

        <div class="section" id="example">
          <h2>Пример</h2>
          Нека да разгледаме прост пример, адаптиран от статия за Servant<a href="#servant-paper">[1]</a>, но модернизиран за днешното състояние на библиотеката.
          <br>
          Той ще служи за обяснения и демонстрация на останалите функционалности:
          <pre><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE GeneralisedNewtypeDeriving #-}

import Data.Aeson
import Servant.API

newtype CounterVal = CounterVal {getCounterVal :: Int}
  deriving (Show, Num, FromJSON, ToJSON)

type Counter = GetCounter :<|> StepCounter
type GetCounter = Get '[JSON] CounterVal
type StepCounter = "step" :> PostNoContent
          </code></pre>
          За да се изпробват примерите из документа ще са нужни няколко библиотеки - aeson, servant, servant-server, servant-client, servant-docs.
          <br><br>
          Първите няколко реда - <code>LANGUAGE</code> директивите пускат нужните разширения на езика, за по-сложни манипулации на типове.
          <br>
          <code>import</code> декларациите служат за вкарване на нужните ни библиотечни функции и типове.
          <br><br>
          В примера ще дефинираме API към число брояч с две крайни точки:
          <ul>
            <li> <code>/</code> - коренът на API-то ни ще служи за взимане на сегашната стойност на брояча</li>
            <li> <code>/step</code> - ще служи за инкрементиране на брояча</li>
          </ul>
          Като добра Haskell практика правим нов тип който да обвива брояча ни, различавайки го като тип от "чист" <code>Int</code>,
          <br>
          По-късно ще се възползваме от това, за да закачим допълнителна информация към него, при генерирането на документация.
          <br>
          Благодарение на богатия <code>deriving</code> механизъм на Haskell за преизползване на имплементации на типови класове (нещо наподобяващо интърфейси в ООП света),
          можем автоматично да получим (в този ред) обръщане към низ, операции за числа, десереализация от JSON и сереализация към JSON
          <br>
          Имплементациите на тези операции съответстват едно към едно с тези на типа който обвиваме (в този случай <code>Int</code>), което позволява и това автомагическо преизползване.
          <br><br>
          Нека разгледаме по-подробно останалата част от програмата ни:
          <h4><code>type Counter = GetCounter :<|> StepCounter</code></h4>
          Тук декларираме типов синоним - както се разбрахме, нашето API ще е изразено като <b>тип</b> в Haskell.
          <br>
          Типът <code>Counter</code> представлява цялото ни API - то е комбинация, чрез оператора <code>:<|></code>,
          на два други типа - <code>GetCounter</code> и <code>StepCounter</code>.
          <br>
          В Haskell операторът <code>a <|> b</code> (или някаква негова вариация) често се използва за да се означи "а или b", по подоба на граматики.
          <br>
          В този случай <code>:<|></code> е <b>типов оператор</b>, взимащ като аргументи две други API-та, означавайки комбинацията им:
          <br>
          Ако искаме да направим заявка към <code>GetCounter :<|> StepCounter</code>, трябва да направим заявка към <code>GetCounter</code> <b>или</b> към <code>StepCounter</code>.
          <h4><code>type GetCounter = Get '[JSON] CounterVal</code></h4>
          Типовият синоним <code>GetCounter</code> ще е крайната точка на която можем да вземем сегашното състояние на брояча.
          <br>
          За да декларираме една крайна точка трябва да кажем няколко неща:
          <ul>
            <li><b>на какъв HTTP метод ще отговаря</b></li>
            Тази роля изпълнява <code>Get</code> - още една типова функция, с два аргумента, разяснени по-долу.
            <li><b>на какви формати ще отговаря</b></li>
            В HTTP света това е на какъв <code>Accept</code> header ще отговаряме и съотвенто какъв <code>Content-Type</code> ще връщаме.
            <br>
            В нашия случай това е JSON - подадено като първи аргумент на <code>Get</code> в <b>списък на ниво типове</b> с един елемент -
            <b>типът <code>JSON</code></b>.
            <br>
            Ако искахме да можем да отговаряме освен това и с <code>text/plain</code> бихме направили този списък <code>'[JSON, PlainText]</code>.
            <li><b>с какви данни ще отговаря</b></li>
            В нашия случай това са данни от типа <code>CounterVal</code>, подаден като втори аргумент на <code>Get</code>.
            <br>
            Ключов момент тук е, че преди да се опитаме да сервираме/правим заявки, трябва нашият тип да поддържа подадените като втори аргумент формати.
            Иначе програмата няма да се компилира, както и искаме, защото няма как да Servant да измисли от нищото как да направи конверсиите от нашия произволен тип
            към/от исканите формати.
            <br>
            Тук тази роля изпълняват инстанциите на <code>FromJSON</code> и <code>ToJSON</code> за <code>CounterVal</code>.
          </ul>
          <h4><code>type StepCounter = "step" :> PostNoContent</code></h4>
          Типовият синоним <code>StepCounter</code> ще е крайната точка на която можем да инкрементираме брояча ни.
          <br>
          Тук виждаме нов типове оператор - <code>:></code>. Той взима два аргумента - <b>низ на ниво типове</b> и друго API.
          <br>
          Ако с <code>:<|></code> изразяваме "разклонение", то с <code>:></code> изразяваме "задълбаване":
          <br>
          Ако искаме да направим заявка към <code>"step" :> B</code> то трябва да направим заявка към <code>B</code>, като на пътя в заявката трябва да сложим префикс <code>step/</code>.
          <br>
          Трябва да се отбележи че с него можем да вкарваме и допълнителни "аргументи" към заявка - например параметри на заявката, header-и, обхващани стойности от пътя.
          Те ще бъдат разгледани по-подробно в <a href="#combinators">Основни комбинатори</a>.
          <br>
          Вторият аргумент на <code>:></code> - типът <code>PostNoContent</code>, е удобен вграден синоним, който индикира че:
          <ul>
            <li>ще отговаряме на <code>POST</code> заявки</li>
            <li>няма да връщаме никакво съдържание - съответно нямаме и никакви формати за (де)кодиране</li>
            <li>от страната на сървъра ще връщаме <code>204 No Content</code></li>
          </ul>
          <br>
          Важно е да се отбележи че всичката тази информация не "прави" нищо сама по себе си - тя е важна по-късно когато искаме да използваме по някакъв начин API-то,
          било то имплементиране сървър за него, правене на заявки към него или генериране на документация за него.
        </div>

        <div class="section" id="combinators">
          <h2>Основни комбинатори</h2>
          WIP
        </div>

        <div class="section" id="serving">
          <h2>Имплементиране на сървър</h2>
          WIP
        </div>

        <div class="section" id="querying">
          <h2>Правене на заявки към сървър</h2>
          WIP
        </div>

        <div class="section" id="docs">
          <h2>Генериране на документация</h2>
          WIP
        </div>

        <div class="section" id="resources">
          <h2> Използвани ресурси </h2>
          <ol>
            <li id="servant-frontpage"> <a href="https://www.servant.dev"> "Servant"</a> <br> [https://www.servant.dev], посетено последно на 12.04.2020</li>
            <li id="servant-paper"> <a href="https://alpmestan.com/servant/servant-wgp.pdf"> "Type-level Web APIs with Servant"</a> <br> [https://alpmestan.com/servant/servant-wgp.pdf], посетено последно на 12.04.2020</li>
          </ol>
        </div>
      </div>
    </div>

    <script src="vanillajs-scrollspy-master/dist/vanillajs-scrollspy.min.js"></script>
    <script>
      const navbar = document.querySelector('#navig');
      const scrollspy = new VanillaScrollspy(navbar);
      scrollspy.init();
    </script>
  </body>
</html>
